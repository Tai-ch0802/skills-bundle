# 模式選擇指南

> 選擇架構模式的決策樹。

## 主要決策樹

```
開始：你的主要關注是什麼？

┌─ 資料存取複雜度？
│  ├─ 高（複雜查詢、需要測試）
│  │  → Repository 模式 + Unit of Work
│  │  驗證：資料來源是否會經常改變？
│  │     ├─ 是 → Repository 值得間接層
│  │     └─ 否 → 考慮更簡單的 ORM 直接存取
│  └─ 低（簡單 CRUD、單一資料庫）
│     → 直接使用 ORM（Prisma、Drizzle）
│     更簡單 = 更好、更快
│
├─ 業務規則複雜度？
│  ├─ 高（領域邏輯、規則因情境而異）
│  │  → 領域驅動設計
│  │  驗證：團隊中是否有領域專家？
│  │     ├─ 是 → 完整 DDD（聚合根、值物件）
│  │     └─ 否 → 部分 DDD（豐富實體、清晰邊界）
│  └─ 低（主要是 CRUD、簡單驗證）
│     → 交易腳本模式
│     更簡單 = 更好、更快
│
├─ 是否需要獨立擴展？
│  ├─ 是（不同元件有不同的擴展需求）
│  │  → 微服務值得其複雜度
│  │  需求（全部必須為真）：
│  │    - 清晰的領域邊界
│  │    - 團隊 > 10 名開發者
│  │    - 每個服務有不同的擴展需求
│  │  若未全部滿足 → 改用模組化單體
│  └─ 否（所有東西一起擴展）
│     → 模組化單體
│     之後在證明需要時再抽取服務
│
└─ 即時需求？
   ├─ 高（即時更新、多使用者同步）
   │  → 事件驅動架構
   │  → 訊息佇列（RabbitMQ、Redis、Kafka）
   │  驗證：能否處理最終一致性？
   │     ├─ 是 → 事件驅動有效
   │     └─ 否 → 同步加輪詢
   └─ 低（最終一致性可接受）
      → 同步（REST/GraphQL）
      更簡單 = 更好、更快
```

## 三個問題（在使用任何模式前）

1. **解決的問題**：這個模式解決了什麼具體問題？
2. **更簡單的替代方案**：是否有更簡單的解決方案？
3. **延遲複雜度**：我們能否在需要時再加入？

## 紅旗（反模式）

| 模式 | 反模式 | 更簡單的替代方案 |
|------|--------|------------------|
| 微服務 | 過早拆分 | 從單體開始，之後再拆分 |
| Clean/六角形 | 過度抽象 | 先用具體實作，之後再加介面 |
| 事件溯源 | 過度設計 | 僅追加的稽核日誌 |
| CQRS | 不必要的複雜度 | 單一模型 |
| Repository | 簡單 CRUD 不需要 | ORM 直接存取 |
